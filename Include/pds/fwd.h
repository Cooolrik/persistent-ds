// WARNING! DO NOT EDIT THIS FILE! This file is generated.

// pds - Persistent data structure framework, Copyright (c) 2022 Ulrik Lindahl
// Licensed under the MIT license https://github.com/Cooolrik/pds/blob/main/LICENSE
#pragma once
#ifndef __PDS__FWD_H__
#define __PDS__FWD_H__

// fwd.h - Forward declaration of types used in pds

#include <limits.h>
#include <float.h>
#include <string>
#include <vector>
#include <memory>

#include <ctle/fwd.h>

namespace pds
{

// scalar types
typedef std::int8_t i8;
typedef std::int16_t i16;
typedef std::int32_t i32;
typedef std::int64_t i64;
typedef std::uint8_t u8;
typedef std::uint16_t u16;
typedef std::uint32_t u32;
typedef std::uint64_t u64;
typedef float f32;
typedef double f64;

using std::string;
using std::unique_ptr;

using ctle::status;
template<class _ValTy> using status_return = ctle::status_return<ctle::status, _ValTy>;
using ctle::uuid;
using hash = ctle::digest<256>;
using ctle::to_string;
using ctle::to_hex_string;

// integer vector types
typedef ctle::n_tup<i8,2> i8vec2;
typedef ctle::n_tup<i8,3> i8vec3;
typedef ctle::n_tup<i8,4> i8vec4;
typedef ctle::n_tup<i16,2> i16vec2;
typedef ctle::n_tup<i16,3> i16vec3;
typedef ctle::n_tup<i16,4> i16vec4;
typedef ctle::n_tup<i32,2> i32vec2;
typedef ctle::n_tup<i32,3> i32vec3;
typedef ctle::n_tup<i32,4> i32vec4;
typedef ctle::n_tup<i64,2> i64vec2;
typedef ctle::n_tup<i64,3> i64vec3;
typedef ctle::n_tup<i64,4> i64vec4;

typedef ctle::n_tup<u8,2> u8vec2;
typedef ctle::n_tup<u8,3> u8vec3;
typedef ctle::n_tup<u8,4> u8vec4;
typedef ctle::n_tup<u16,2> u16vec2;
typedef ctle::n_tup<u16,3> u16vec3;
typedef ctle::n_tup<u16,4> u16vec4;
typedef ctle::n_tup<u32,2> u32vec2;
typedef ctle::n_tup<u32,3> u32vec3;
typedef ctle::n_tup<u32,4> u32vec4;
typedef ctle::n_tup<u64,2> u64vec2;
typedef ctle::n_tup<u64,3> u64vec3;
typedef ctle::n_tup<u64,4> u64vec4;

// float vector types
typedef ctle::n_tup<f32,2> f32vec2;
typedef ctle::n_tup<f32,3> f32vec3;
typedef ctle::n_tup<f32,4> f32vec4;
typedef ctle::n_tup<f64,2> f64vec2;
typedef ctle::n_tup<f64,3> f64vec3;
typedef ctle::n_tup<f64,4> f64vec4;

// float matrix types
typedef ctle::mn_tup<f32,2,2> f32mat2;
typedef ctle::mn_tup<f32,3,3> f32mat3;
typedef ctle::mn_tup<f32,4,4> f32mat4;
typedef ctle::mn_tup<f64,2,2> f64mat2;
typedef ctle::mn_tup<f64,3,3> f64mat3;
typedef ctle::mn_tup<f64,4,4> f64mat4;

// quaternion types
class f32quat;
class f64quat;

// item and entity references
class item_ref;
class entity_ref;

// shorthand for commonly used types
typedef u32 uint;
typedef i32vec2 ivec2;
typedef i32vec3 ivec3;
typedef i32vec4 ivec4;
typedef u32vec2 uvec2;
typedef u32vec3 uvec3;
typedef u32vec4 uvec4;
typedef f32vec2 vec2;
typedef f32vec3 vec3;
typedef f32vec4 vec4;
typedef f32mat2 mat2;
typedef f32mat3 mat3;
typedef f32mat4 mat4;

// container types
template <class _Ty> using vector = std::vector<_Ty>;
template <class _Ty> using idx_vector = ctle::idx_vector<_Ty,vector<u32>>;
template <class _Ty> using optional_idx_vector = ctle::optional_idx_vector<_Ty,vector<u32>>;
template <class _Ty> using optional_value = ctle::optional_value<_Ty>;
template <class _Ty> using optional_vector = ctle::optional_vector<_Ty>;

// @brief element_type_information stores information on the element types in pds
template <class _Ty> struct element_type_information;

// @brief value_type_information stores information on the value types in pds, which is a combination of element types with containers
template <class _Ty> struct value_type_information;

// @brief container_type_index stores the container type index of the container types in pds
enum class container_type_index : uint;

// @brief element_type_index stores the element type index in pds
enum class element_type_index : uint;

// @brief validation_error_flags is a bitmask of validation error flags in pds
enum class validation_error_flags : u64;
constexpr validation_error_flags operator|(validation_error_flags lhs, validation_error_flags rhs) { return validation_error_flags( u64(lhs) | u64(rhs) ); }

// @brief directed_graph_flags is a bitmask of flags used to control the set up and validation of DirectedGraph
enum class directed_graph_flags : uint;
constexpr directed_graph_flags operator|(directed_graph_flags lhs, directed_graph_flags rhs) { return directed_graph_flags( uint(lhs) | uint(rhs) ); }

// @brief item_table_flags is a bitmask of flags used to control the set up and validation of item table
enum class item_table_flags : uint;
constexpr item_table_flags operator|(item_table_flags lhs, item_table_flags rhs) { return item_table_flags( uint(lhs) | uint(rhs) ); }

class Entity;
class EntityWriter;
class EntityReader;
class EntityValidator;
class WriteStream;
class ReadStream;

// @brief IndexedVector is the template class for all indexed vectors in pds
template <
	class _Ty, /* the type of the value in the vector */
	class _IdxTy = u32, /* the type of the index in the vector */
	class _Base = ctle::idx_vector<_Ty,std::vector<_IdxTy>> /* the base class of the vector, use to override implementation and allocations etc. */
> class IndexedVector;

// @brief BidirectionalMap is a bi-directional map class, which can be traversed in both directions
template <
	class _Kty,
	class _Vty,
	class _Base = ctle::bimap<_Kty, _Vty>
> class BidirectionalMap;

// @brief DirectedGraph is a directed graph class, with support for multiple roots and acyclic graph validation
template <
	class _Ty,
	directed_graph_flags _Flags = directed_graph_flags(0),
	class _EdgesSetTy = std::set<std::pair<const _Ty, const _Ty>>,
	class _RootsSetTy = std::set<_Ty>
> class DirectedGraph;

// @brief ItemTable holds a map of key values to unique memory mapped objects, items in a pds entity.
template <
	class _Kty,
	class _Ty,
	item_table_flags _Flags = item_table_flags(0),
	class _MapTy = std::unordered_map<_Kty, std::unique_ptr<_Ty>>
> class ItemTable;
}
// namespace pds

#endif//__PDS__FWD_H__
