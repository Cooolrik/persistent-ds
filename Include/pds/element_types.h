// WARNING! DO NOT EDIT THIS FILE! This file is generated.

// pds - Persistent data structure framework, Copyright (c) 2022 Ulrik Lindahl
// Licensed under the MIT license https://github.com/Cooolrik/pds/blob/main/LICENSE
#pragma once
#ifndef __PDS__ELEMENT_TYPES_H__
#define __PDS__ELEMENT_TYPES_H__

// element_types.h - Declaration of element types used in pds.
// Element types are the basic building blocks of the data structures, and can be serialized.

#include <ctle/ntup.h>

#include "entity_ref.h"
#include "item_ref.h"

namespace pds
{

// zero/inf(min)/sup(max) values for the element types
constexpr bool bool_zero = false;
constexpr bool bool_inf = false;
constexpr bool bool_sup = true;
constexpr i8 i8_zero = 0;
constexpr i8 i8_inf = INT8_MIN;
constexpr i8 i8_sup = INT8_MAX;
constexpr i16 i16_zero = 0;
constexpr i16 i16_inf = INT16_MIN;
constexpr i16 i16_sup = INT16_MAX;
constexpr i32 i32_zero = 0;
constexpr i32 i32_inf = INT32_MIN;
constexpr i32 i32_sup = INT32_MAX;
constexpr i64 i64_zero = 0;
constexpr i64 i64_inf = INT64_MIN;
constexpr i64 i64_sup = INT64_MAX;
constexpr u8 u8_zero = 0;
constexpr u8 u8_inf = 0;
constexpr u8 u8_sup = UINT8_MAX;
constexpr u16 u16_zero = 0;
constexpr u16 u16_inf = 0;
constexpr u16 u16_sup = UINT16_MAX;
constexpr u32 u32_zero = 0;
constexpr u32 u32_inf = 0;
constexpr u32 u32_sup = UINT32_MAX;
constexpr u64 u64_zero = 0;
constexpr u64 u64_inf = 0;
constexpr u64 u64_sup = UINT64_MAX;

constexpr f32 f32_zero = 0.0f;
constexpr f32 f32_inf = -FLT_MAX;
constexpr f32 f32_sup = FLT_MAX;
constexpr f64 f64_zero = 0.0;
constexpr f64 f64_inf = -DBL_MAX;
constexpr f64 f64_sup = DBL_MAX;

const string string_zero;
const string string_inf;

constexpr uuid uuid_zero = uuid::zero();
constexpr uuid uuid_inf = uuid::inf();
constexpr uuid uuid_sup = uuid::sup();

constexpr hash hash_zero = hash::zero();
constexpr hash hash_inf = hash::inf();
constexpr hash hash_sup = hash::sup();

// quaternion types
class f32quat : public f32vec4
{
public:
	f32quat() : f32vec4() {}
	f32quat( const f32quat &other ) : f32vec4( other ) {}
	f32quat( f32 _a, f32 _b, f32 _c, f32 _d ) : f32vec4(_a,_b,_c,_d) {}
	f32quat &operator=( const f32quat &other ) noexcept { x = other.x; y = other.y; z = other.z; w = other.w; return *this; }
};

class f64quat : public f64vec4
{
public:
	f64quat() : f64vec4() {}
	f64quat( const f64quat &other ) : f64vec4( other ) {}
	f64quat( f64 _a, f64 _b, f64 _c, f64 _d ) : f64vec4(_a,_b,_c,_d) {}
	f64quat &operator=( const f64quat &other ) noexcept { x = other.x; y = other.y; z = other.z; w = other.w; return *this; }
};

// all element type indices
enum class element_type_index : uint
{
	dt_bool = 0x11,
	dt_i8 = 0x21,
	dt_i16 = 0x22,
	dt_i32 = 0x23,
	dt_i64 = 0x24,
	dt_u8 = 0x31,
	dt_u16 = 0x32,
	dt_u32 = 0x33,
	dt_u64 = 0x34,
	dt_f32 = 0x41,
	dt_f64 = 0x42,
	dt_f32vec2 = 0x51,
	dt_f64vec2 = 0x52,
	dt_f32vec3 = 0x61,
	dt_f64vec3 = 0x62,
	dt_f32vec4 = 0x71,
	dt_f64vec4 = 0x72,
	dt_i8vec2 = 0x81,
	dt_i16vec2 = 0x82,
	dt_i32vec2 = 0x83,
	dt_i64vec2 = 0x84,
	dt_i8vec3 = 0x91,
	dt_i16vec3 = 0x92,
	dt_i32vec3 = 0x93,
	dt_i64vec3 = 0x94,
	dt_i8vec4 = 0xa1,
	dt_i16vec4 = 0xa2,
	dt_i32vec4 = 0xa3,
	dt_i64vec4 = 0xa4,
	dt_u8vec2 = 0xb1,
	dt_u16vec2 = 0xb2,
	dt_u32vec2 = 0xb3,
	dt_u64vec2 = 0xb4,
	dt_u8vec3 = 0xc1,
	dt_u16vec3 = 0xc2,
	dt_u32vec3 = 0xc3,
	dt_u64vec3 = 0xc4,
	dt_u8vec4 = 0xd1,
	dt_u16vec4 = 0xd2,
	dt_u32vec4 = 0xd3,
	dt_u64vec4 = 0xd4,
	dt_f32mat2 = 0xe1,
	dt_f64mat2 = 0xe2,
	dt_f32mat3 = 0xf1,
	dt_f64mat3 = 0xf2,
	dt_f32mat4 = 0x101,
	dt_f64mat4 = 0x102,
	dt_f32quat = 0x111,
	dt_f64quat = 0x112,
	dt_uuid = 0x121,
	dt_item_ref = 0x122,
	dt_hash = 0x131,
	dt_entity_ref = 0x132,
	dt_string = 0x141,
};

template<> struct element_type_information<bool>
{
	typedef bool value_type; // the value type of bool ( bool )
	static constexpr size_t value_count = 1; // the number of values in bool ( 1 )
	static constexpr const char * value_name = "bool"; // name of the value in bool ( "bool" ) 
	static constexpr const char * type_name = "bool"; // name of the type ( "bool" ) 
	static constexpr element_type_index type_index = element_type_index::dt_bool; // the element type index of bool ( dt_bool )
	static const bool zero; // zero value of bool
	static const bool inf; // limit inferior (minimum possible value) of bool
	static const bool sup; // limit superior (maximum possible value) of bool
};

template<> struct element_type_information<i8>
{
	typedef i8 value_type; // the value type of i8 ( i8 )
	static constexpr size_t value_count = 1; // the number of values in i8 ( 1 )
	static constexpr const char * value_name = "i8"; // name of the value in i8 ( "i8" ) 
	static constexpr const char * type_name = "i8"; // name of the type ( "i8" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i8; // the element type index of i8 ( dt_i8 )
	static const i8 zero; // zero value of i8
	static const i8 inf; // limit inferior (minimum possible value) of i8
	static const i8 sup; // limit superior (maximum possible value) of i8
};

template<> struct element_type_information<i16>
{
	typedef i16 value_type; // the value type of i16 ( i16 )
	static constexpr size_t value_count = 1; // the number of values in i16 ( 1 )
	static constexpr const char * value_name = "i16"; // name of the value in i16 ( "i16" ) 
	static constexpr const char * type_name = "i16"; // name of the type ( "i16" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i16; // the element type index of i16 ( dt_i16 )
	static const i16 zero; // zero value of i16
	static const i16 inf; // limit inferior (minimum possible value) of i16
	static const i16 sup; // limit superior (maximum possible value) of i16
};

template<> struct element_type_information<i32>
{
	typedef i32 value_type; // the value type of i32 ( i32 )
	static constexpr size_t value_count = 1; // the number of values in i32 ( 1 )
	static constexpr const char * value_name = "i32"; // name of the value in i32 ( "i32" ) 
	static constexpr const char * type_name = "i32"; // name of the type ( "i32" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i32; // the element type index of i32 ( dt_i32 )
	static const i32 zero; // zero value of i32
	static const i32 inf; // limit inferior (minimum possible value) of i32
	static const i32 sup; // limit superior (maximum possible value) of i32
};

template<> struct element_type_information<i64>
{
	typedef i64 value_type; // the value type of i64 ( i64 )
	static constexpr size_t value_count = 1; // the number of values in i64 ( 1 )
	static constexpr const char * value_name = "i64"; // name of the value in i64 ( "i64" ) 
	static constexpr const char * type_name = "i64"; // name of the type ( "i64" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i64; // the element type index of i64 ( dt_i64 )
	static const i64 zero; // zero value of i64
	static const i64 inf; // limit inferior (minimum possible value) of i64
	static const i64 sup; // limit superior (maximum possible value) of i64
};

template<> struct element_type_information<u8>
{
	typedef u8 value_type; // the value type of u8 ( u8 )
	static constexpr size_t value_count = 1; // the number of values in u8 ( 1 )
	static constexpr const char * value_name = "u8"; // name of the value in u8 ( "u8" ) 
	static constexpr const char * type_name = "u8"; // name of the type ( "u8" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u8; // the element type index of u8 ( dt_u8 )
	static const u8 zero; // zero value of u8
	static const u8 inf; // limit inferior (minimum possible value) of u8
	static const u8 sup; // limit superior (maximum possible value) of u8
};

template<> struct element_type_information<u16>
{
	typedef u16 value_type; // the value type of u16 ( u16 )
	static constexpr size_t value_count = 1; // the number of values in u16 ( 1 )
	static constexpr const char * value_name = "u16"; // name of the value in u16 ( "u16" ) 
	static constexpr const char * type_name = "u16"; // name of the type ( "u16" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u16; // the element type index of u16 ( dt_u16 )
	static const u16 zero; // zero value of u16
	static const u16 inf; // limit inferior (minimum possible value) of u16
	static const u16 sup; // limit superior (maximum possible value) of u16
};

template<> struct element_type_information<u32>
{
	typedef u32 value_type; // the value type of u32 ( u32 )
	static constexpr size_t value_count = 1; // the number of values in u32 ( 1 )
	static constexpr const char * value_name = "u32"; // name of the value in u32 ( "u32" ) 
	static constexpr const char * type_name = "u32"; // name of the type ( "u32" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u32; // the element type index of u32 ( dt_u32 )
	static const u32 zero; // zero value of u32
	static const u32 inf; // limit inferior (minimum possible value) of u32
	static const u32 sup; // limit superior (maximum possible value) of u32
};

template<> struct element_type_information<u64>
{
	typedef u64 value_type; // the value type of u64 ( u64 )
	static constexpr size_t value_count = 1; // the number of values in u64 ( 1 )
	static constexpr const char * value_name = "u64"; // name of the value in u64 ( "u64" ) 
	static constexpr const char * type_name = "u64"; // name of the type ( "u64" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u64; // the element type index of u64 ( dt_u64 )
	static const u64 zero; // zero value of u64
	static const u64 inf; // limit inferior (minimum possible value) of u64
	static const u64 sup; // limit superior (maximum possible value) of u64
};

template<> struct element_type_information<f32>
{
	typedef f32 value_type; // the value type of f32 ( f32 )
	static constexpr size_t value_count = 1; // the number of values in f32 ( 1 )
	static constexpr const char * value_name = "f32"; // name of the value in f32 ( "f32" ) 
	static constexpr const char * type_name = "f32"; // name of the type ( "f32" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32; // the element type index of f32 ( dt_f32 )
	static const f32 zero; // zero value of f32
	static const f32 inf; // limit inferior (minimum possible value) of f32
	static const f32 sup; // limit superior (maximum possible value) of f32
};

template<> struct element_type_information<f64>
{
	typedef f64 value_type; // the value type of f64 ( f64 )
	static constexpr size_t value_count = 1; // the number of values in f64 ( 1 )
	static constexpr const char * value_name = "f64"; // name of the value in f64 ( "f64" ) 
	static constexpr const char * type_name = "f64"; // name of the type ( "f64" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64; // the element type index of f64 ( dt_f64 )
	static const f64 zero; // zero value of f64
	static const f64 inf; // limit inferior (minimum possible value) of f64
	static const f64 sup; // limit superior (maximum possible value) of f64
};

template<> struct element_type_information<i8vec2>
{
	typedef i8 value_type; // the value type of i8vec2 ( i8 )
	static constexpr size_t value_count = 2; // the number of values in i8vec2 ( 2 )
	static constexpr const char * value_name = "i8"; // name of the value in i8vec2 ( "i8" ) 
	static constexpr const char * type_name = "i8vec2"; // name of the type ( "i8vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i8vec2; // the element type index of i8vec2 ( dt_i8vec2 )
	static const i8vec2 zero; // zero value of i8vec2
	static const i8vec2 inf; // limit inferior (minimum possible value) of i8vec2
	static const i8vec2 sup; // limit superior (maximum possible value) of i8vec2
};

template<> struct element_type_information<i8vec3>
{
	typedef i8 value_type; // the value type of i8vec3 ( i8 )
	static constexpr size_t value_count = 3; // the number of values in i8vec3 ( 3 )
	static constexpr const char * value_name = "i8"; // name of the value in i8vec3 ( "i8" ) 
	static constexpr const char * type_name = "i8vec3"; // name of the type ( "i8vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i8vec3; // the element type index of i8vec3 ( dt_i8vec3 )
	static const i8vec3 zero; // zero value of i8vec3
	static const i8vec3 inf; // limit inferior (minimum possible value) of i8vec3
	static const i8vec3 sup; // limit superior (maximum possible value) of i8vec3
};

template<> struct element_type_information<i8vec4>
{
	typedef i8 value_type; // the value type of i8vec4 ( i8 )
	static constexpr size_t value_count = 4; // the number of values in i8vec4 ( 4 )
	static constexpr const char * value_name = "i8"; // name of the value in i8vec4 ( "i8" ) 
	static constexpr const char * type_name = "i8vec4"; // name of the type ( "i8vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i8vec4; // the element type index of i8vec4 ( dt_i8vec4 )
	static const i8vec4 zero; // zero value of i8vec4
	static const i8vec4 inf; // limit inferior (minimum possible value) of i8vec4
	static const i8vec4 sup; // limit superior (maximum possible value) of i8vec4
};

template<> struct element_type_information<i16vec2>
{
	typedef i16 value_type; // the value type of i16vec2 ( i16 )
	static constexpr size_t value_count = 2; // the number of values in i16vec2 ( 2 )
	static constexpr const char * value_name = "i16"; // name of the value in i16vec2 ( "i16" ) 
	static constexpr const char * type_name = "i16vec2"; // name of the type ( "i16vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i16vec2; // the element type index of i16vec2 ( dt_i16vec2 )
	static const i16vec2 zero; // zero value of i16vec2
	static const i16vec2 inf; // limit inferior (minimum possible value) of i16vec2
	static const i16vec2 sup; // limit superior (maximum possible value) of i16vec2
};

template<> struct element_type_information<i16vec3>
{
	typedef i16 value_type; // the value type of i16vec3 ( i16 )
	static constexpr size_t value_count = 3; // the number of values in i16vec3 ( 3 )
	static constexpr const char * value_name = "i16"; // name of the value in i16vec3 ( "i16" ) 
	static constexpr const char * type_name = "i16vec3"; // name of the type ( "i16vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i16vec3; // the element type index of i16vec3 ( dt_i16vec3 )
	static const i16vec3 zero; // zero value of i16vec3
	static const i16vec3 inf; // limit inferior (minimum possible value) of i16vec3
	static const i16vec3 sup; // limit superior (maximum possible value) of i16vec3
};

template<> struct element_type_information<i16vec4>
{
	typedef i16 value_type; // the value type of i16vec4 ( i16 )
	static constexpr size_t value_count = 4; // the number of values in i16vec4 ( 4 )
	static constexpr const char * value_name = "i16"; // name of the value in i16vec4 ( "i16" ) 
	static constexpr const char * type_name = "i16vec4"; // name of the type ( "i16vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i16vec4; // the element type index of i16vec4 ( dt_i16vec4 )
	static const i16vec4 zero; // zero value of i16vec4
	static const i16vec4 inf; // limit inferior (minimum possible value) of i16vec4
	static const i16vec4 sup; // limit superior (maximum possible value) of i16vec4
};

template<> struct element_type_information<i32vec2>
{
	typedef i32 value_type; // the value type of i32vec2 ( i32 )
	static constexpr size_t value_count = 2; // the number of values in i32vec2 ( 2 )
	static constexpr const char * value_name = "i32"; // name of the value in i32vec2 ( "i32" ) 
	static constexpr const char * type_name = "i32vec2"; // name of the type ( "i32vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i32vec2; // the element type index of i32vec2 ( dt_i32vec2 )
	static const i32vec2 zero; // zero value of i32vec2
	static const i32vec2 inf; // limit inferior (minimum possible value) of i32vec2
	static const i32vec2 sup; // limit superior (maximum possible value) of i32vec2
};

template<> struct element_type_information<i32vec3>
{
	typedef i32 value_type; // the value type of i32vec3 ( i32 )
	static constexpr size_t value_count = 3; // the number of values in i32vec3 ( 3 )
	static constexpr const char * value_name = "i32"; // name of the value in i32vec3 ( "i32" ) 
	static constexpr const char * type_name = "i32vec3"; // name of the type ( "i32vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i32vec3; // the element type index of i32vec3 ( dt_i32vec3 )
	static const i32vec3 zero; // zero value of i32vec3
	static const i32vec3 inf; // limit inferior (minimum possible value) of i32vec3
	static const i32vec3 sup; // limit superior (maximum possible value) of i32vec3
};

template<> struct element_type_information<i32vec4>
{
	typedef i32 value_type; // the value type of i32vec4 ( i32 )
	static constexpr size_t value_count = 4; // the number of values in i32vec4 ( 4 )
	static constexpr const char * value_name = "i32"; // name of the value in i32vec4 ( "i32" ) 
	static constexpr const char * type_name = "i32vec4"; // name of the type ( "i32vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i32vec4; // the element type index of i32vec4 ( dt_i32vec4 )
	static const i32vec4 zero; // zero value of i32vec4
	static const i32vec4 inf; // limit inferior (minimum possible value) of i32vec4
	static const i32vec4 sup; // limit superior (maximum possible value) of i32vec4
};

template<> struct element_type_information<i64vec2>
{
	typedef i64 value_type; // the value type of i64vec2 ( i64 )
	static constexpr size_t value_count = 2; // the number of values in i64vec2 ( 2 )
	static constexpr const char * value_name = "i64"; // name of the value in i64vec2 ( "i64" ) 
	static constexpr const char * type_name = "i64vec2"; // name of the type ( "i64vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i64vec2; // the element type index of i64vec2 ( dt_i64vec2 )
	static const i64vec2 zero; // zero value of i64vec2
	static const i64vec2 inf; // limit inferior (minimum possible value) of i64vec2
	static const i64vec2 sup; // limit superior (maximum possible value) of i64vec2
};

template<> struct element_type_information<i64vec3>
{
	typedef i64 value_type; // the value type of i64vec3 ( i64 )
	static constexpr size_t value_count = 3; // the number of values in i64vec3 ( 3 )
	static constexpr const char * value_name = "i64"; // name of the value in i64vec3 ( "i64" ) 
	static constexpr const char * type_name = "i64vec3"; // name of the type ( "i64vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i64vec3; // the element type index of i64vec3 ( dt_i64vec3 )
	static const i64vec3 zero; // zero value of i64vec3
	static const i64vec3 inf; // limit inferior (minimum possible value) of i64vec3
	static const i64vec3 sup; // limit superior (maximum possible value) of i64vec3
};

template<> struct element_type_information<i64vec4>
{
	typedef i64 value_type; // the value type of i64vec4 ( i64 )
	static constexpr size_t value_count = 4; // the number of values in i64vec4 ( 4 )
	static constexpr const char * value_name = "i64"; // name of the value in i64vec4 ( "i64" ) 
	static constexpr const char * type_name = "i64vec4"; // name of the type ( "i64vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_i64vec4; // the element type index of i64vec4 ( dt_i64vec4 )
	static const i64vec4 zero; // zero value of i64vec4
	static const i64vec4 inf; // limit inferior (minimum possible value) of i64vec4
	static const i64vec4 sup; // limit superior (maximum possible value) of i64vec4
};

template<> struct element_type_information<u8vec2>
{
	typedef u8 value_type; // the value type of u8vec2 ( u8 )
	static constexpr size_t value_count = 2; // the number of values in u8vec2 ( 2 )
	static constexpr const char * value_name = "u8"; // name of the value in u8vec2 ( "u8" ) 
	static constexpr const char * type_name = "u8vec2"; // name of the type ( "u8vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u8vec2; // the element type index of u8vec2 ( dt_u8vec2 )
	static const u8vec2 zero; // zero value of u8vec2
	static const u8vec2 inf; // limit inferior (minimum possible value) of u8vec2
	static const u8vec2 sup; // limit superior (maximum possible value) of u8vec2
};

template<> struct element_type_information<u8vec3>
{
	typedef u8 value_type; // the value type of u8vec3 ( u8 )
	static constexpr size_t value_count = 3; // the number of values in u8vec3 ( 3 )
	static constexpr const char * value_name = "u8"; // name of the value in u8vec3 ( "u8" ) 
	static constexpr const char * type_name = "u8vec3"; // name of the type ( "u8vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u8vec3; // the element type index of u8vec3 ( dt_u8vec3 )
	static const u8vec3 zero; // zero value of u8vec3
	static const u8vec3 inf; // limit inferior (minimum possible value) of u8vec3
	static const u8vec3 sup; // limit superior (maximum possible value) of u8vec3
};

template<> struct element_type_information<u8vec4>
{
	typedef u8 value_type; // the value type of u8vec4 ( u8 )
	static constexpr size_t value_count = 4; // the number of values in u8vec4 ( 4 )
	static constexpr const char * value_name = "u8"; // name of the value in u8vec4 ( "u8" ) 
	static constexpr const char * type_name = "u8vec4"; // name of the type ( "u8vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u8vec4; // the element type index of u8vec4 ( dt_u8vec4 )
	static const u8vec4 zero; // zero value of u8vec4
	static const u8vec4 inf; // limit inferior (minimum possible value) of u8vec4
	static const u8vec4 sup; // limit superior (maximum possible value) of u8vec4
};

template<> struct element_type_information<u16vec2>
{
	typedef u16 value_type; // the value type of u16vec2 ( u16 )
	static constexpr size_t value_count = 2; // the number of values in u16vec2 ( 2 )
	static constexpr const char * value_name = "u16"; // name of the value in u16vec2 ( "u16" ) 
	static constexpr const char * type_name = "u16vec2"; // name of the type ( "u16vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u16vec2; // the element type index of u16vec2 ( dt_u16vec2 )
	static const u16vec2 zero; // zero value of u16vec2
	static const u16vec2 inf; // limit inferior (minimum possible value) of u16vec2
	static const u16vec2 sup; // limit superior (maximum possible value) of u16vec2
};

template<> struct element_type_information<u16vec3>
{
	typedef u16 value_type; // the value type of u16vec3 ( u16 )
	static constexpr size_t value_count = 3; // the number of values in u16vec3 ( 3 )
	static constexpr const char * value_name = "u16"; // name of the value in u16vec3 ( "u16" ) 
	static constexpr const char * type_name = "u16vec3"; // name of the type ( "u16vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u16vec3; // the element type index of u16vec3 ( dt_u16vec3 )
	static const u16vec3 zero; // zero value of u16vec3
	static const u16vec3 inf; // limit inferior (minimum possible value) of u16vec3
	static const u16vec3 sup; // limit superior (maximum possible value) of u16vec3
};

template<> struct element_type_information<u16vec4>
{
	typedef u16 value_type; // the value type of u16vec4 ( u16 )
	static constexpr size_t value_count = 4; // the number of values in u16vec4 ( 4 )
	static constexpr const char * value_name = "u16"; // name of the value in u16vec4 ( "u16" ) 
	static constexpr const char * type_name = "u16vec4"; // name of the type ( "u16vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u16vec4; // the element type index of u16vec4 ( dt_u16vec4 )
	static const u16vec4 zero; // zero value of u16vec4
	static const u16vec4 inf; // limit inferior (minimum possible value) of u16vec4
	static const u16vec4 sup; // limit superior (maximum possible value) of u16vec4
};

template<> struct element_type_information<u32vec2>
{
	typedef u32 value_type; // the value type of u32vec2 ( u32 )
	static constexpr size_t value_count = 2; // the number of values in u32vec2 ( 2 )
	static constexpr const char * value_name = "u32"; // name of the value in u32vec2 ( "u32" ) 
	static constexpr const char * type_name = "u32vec2"; // name of the type ( "u32vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u32vec2; // the element type index of u32vec2 ( dt_u32vec2 )
	static const u32vec2 zero; // zero value of u32vec2
	static const u32vec2 inf; // limit inferior (minimum possible value) of u32vec2
	static const u32vec2 sup; // limit superior (maximum possible value) of u32vec2
};

template<> struct element_type_information<u32vec3>
{
	typedef u32 value_type; // the value type of u32vec3 ( u32 )
	static constexpr size_t value_count = 3; // the number of values in u32vec3 ( 3 )
	static constexpr const char * value_name = "u32"; // name of the value in u32vec3 ( "u32" ) 
	static constexpr const char * type_name = "u32vec3"; // name of the type ( "u32vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u32vec3; // the element type index of u32vec3 ( dt_u32vec3 )
	static const u32vec3 zero; // zero value of u32vec3
	static const u32vec3 inf; // limit inferior (minimum possible value) of u32vec3
	static const u32vec3 sup; // limit superior (maximum possible value) of u32vec3
};

template<> struct element_type_information<u32vec4>
{
	typedef u32 value_type; // the value type of u32vec4 ( u32 )
	static constexpr size_t value_count = 4; // the number of values in u32vec4 ( 4 )
	static constexpr const char * value_name = "u32"; // name of the value in u32vec4 ( "u32" ) 
	static constexpr const char * type_name = "u32vec4"; // name of the type ( "u32vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u32vec4; // the element type index of u32vec4 ( dt_u32vec4 )
	static const u32vec4 zero; // zero value of u32vec4
	static const u32vec4 inf; // limit inferior (minimum possible value) of u32vec4
	static const u32vec4 sup; // limit superior (maximum possible value) of u32vec4
};

template<> struct element_type_information<u64vec2>
{
	typedef u64 value_type; // the value type of u64vec2 ( u64 )
	static constexpr size_t value_count = 2; // the number of values in u64vec2 ( 2 )
	static constexpr const char * value_name = "u64"; // name of the value in u64vec2 ( "u64" ) 
	static constexpr const char * type_name = "u64vec2"; // name of the type ( "u64vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u64vec2; // the element type index of u64vec2 ( dt_u64vec2 )
	static const u64vec2 zero; // zero value of u64vec2
	static const u64vec2 inf; // limit inferior (minimum possible value) of u64vec2
	static const u64vec2 sup; // limit superior (maximum possible value) of u64vec2
};

template<> struct element_type_information<u64vec3>
{
	typedef u64 value_type; // the value type of u64vec3 ( u64 )
	static constexpr size_t value_count = 3; // the number of values in u64vec3 ( 3 )
	static constexpr const char * value_name = "u64"; // name of the value in u64vec3 ( "u64" ) 
	static constexpr const char * type_name = "u64vec3"; // name of the type ( "u64vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u64vec3; // the element type index of u64vec3 ( dt_u64vec3 )
	static const u64vec3 zero; // zero value of u64vec3
	static const u64vec3 inf; // limit inferior (minimum possible value) of u64vec3
	static const u64vec3 sup; // limit superior (maximum possible value) of u64vec3
};

template<> struct element_type_information<u64vec4>
{
	typedef u64 value_type; // the value type of u64vec4 ( u64 )
	static constexpr size_t value_count = 4; // the number of values in u64vec4 ( 4 )
	static constexpr const char * value_name = "u64"; // name of the value in u64vec4 ( "u64" ) 
	static constexpr const char * type_name = "u64vec4"; // name of the type ( "u64vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_u64vec4; // the element type index of u64vec4 ( dt_u64vec4 )
	static const u64vec4 zero; // zero value of u64vec4
	static const u64vec4 inf; // limit inferior (minimum possible value) of u64vec4
	static const u64vec4 sup; // limit superior (maximum possible value) of u64vec4
};

template<> struct element_type_information<f32vec2>
{
	typedef f32 value_type; // the value type of f32vec2 ( f32 )
	static constexpr size_t value_count = 2; // the number of values in f32vec2 ( 2 )
	static constexpr const char * value_name = "f32"; // name of the value in f32vec2 ( "f32" ) 
	static constexpr const char * type_name = "f32vec2"; // name of the type ( "f32vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32vec2; // the element type index of f32vec2 ( dt_f32vec2 )
	static const f32vec2 zero; // zero value of f32vec2
	static const f32vec2 inf; // limit inferior (minimum possible value) of f32vec2
	static const f32vec2 sup; // limit superior (maximum possible value) of f32vec2
};

template<> struct element_type_information<f32vec3>
{
	typedef f32 value_type; // the value type of f32vec3 ( f32 )
	static constexpr size_t value_count = 3; // the number of values in f32vec3 ( 3 )
	static constexpr const char * value_name = "f32"; // name of the value in f32vec3 ( "f32" ) 
	static constexpr const char * type_name = "f32vec3"; // name of the type ( "f32vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32vec3; // the element type index of f32vec3 ( dt_f32vec3 )
	static const f32vec3 zero; // zero value of f32vec3
	static const f32vec3 inf; // limit inferior (minimum possible value) of f32vec3
	static const f32vec3 sup; // limit superior (maximum possible value) of f32vec3
};

template<> struct element_type_information<f32vec4>
{
	typedef f32 value_type; // the value type of f32vec4 ( f32 )
	static constexpr size_t value_count = 4; // the number of values in f32vec4 ( 4 )
	static constexpr const char * value_name = "f32"; // name of the value in f32vec4 ( "f32" ) 
	static constexpr const char * type_name = "f32vec4"; // name of the type ( "f32vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32vec4; // the element type index of f32vec4 ( dt_f32vec4 )
	static const f32vec4 zero; // zero value of f32vec4
	static const f32vec4 inf; // limit inferior (minimum possible value) of f32vec4
	static const f32vec4 sup; // limit superior (maximum possible value) of f32vec4
};

template<> struct element_type_information<f64vec2>
{
	typedef f64 value_type; // the value type of f64vec2 ( f64 )
	static constexpr size_t value_count = 2; // the number of values in f64vec2 ( 2 )
	static constexpr const char * value_name = "f64"; // name of the value in f64vec2 ( "f64" ) 
	static constexpr const char * type_name = "f64vec2"; // name of the type ( "f64vec2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64vec2; // the element type index of f64vec2 ( dt_f64vec2 )
	static const f64vec2 zero; // zero value of f64vec2
	static const f64vec2 inf; // limit inferior (minimum possible value) of f64vec2
	static const f64vec2 sup; // limit superior (maximum possible value) of f64vec2
};

template<> struct element_type_information<f64vec3>
{
	typedef f64 value_type; // the value type of f64vec3 ( f64 )
	static constexpr size_t value_count = 3; // the number of values in f64vec3 ( 3 )
	static constexpr const char * value_name = "f64"; // name of the value in f64vec3 ( "f64" ) 
	static constexpr const char * type_name = "f64vec3"; // name of the type ( "f64vec3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64vec3; // the element type index of f64vec3 ( dt_f64vec3 )
	static const f64vec3 zero; // zero value of f64vec3
	static const f64vec3 inf; // limit inferior (minimum possible value) of f64vec3
	static const f64vec3 sup; // limit superior (maximum possible value) of f64vec3
};

template<> struct element_type_information<f64vec4>
{
	typedef f64 value_type; // the value type of f64vec4 ( f64 )
	static constexpr size_t value_count = 4; // the number of values in f64vec4 ( 4 )
	static constexpr const char * value_name = "f64"; // name of the value in f64vec4 ( "f64" ) 
	static constexpr const char * type_name = "f64vec4"; // name of the type ( "f64vec4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64vec4; // the element type index of f64vec4 ( dt_f64vec4 )
	static const f64vec4 zero; // zero value of f64vec4
	static const f64vec4 inf; // limit inferior (minimum possible value) of f64vec4
	static const f64vec4 sup; // limit superior (maximum possible value) of f64vec4
};

template<> struct element_type_information<f32mat2>
{
	typedef f32 value_type; // the value type of f32mat2 ( f32 )
	static constexpr size_t value_count = 4; // the number of values in f32mat2 ( 4 )
	static constexpr const char * value_name = "f32"; // name of the value in f32mat2 ( "f32" ) 
	static constexpr const char * type_name = "f32mat2"; // name of the type ( "f32mat2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32mat2; // the element type index of f32mat2 ( dt_f32mat2 )
	static const f32mat2 zero; // zero value of f32mat2
	static const f32mat2 inf; // limit inferior (minimum possible value) of f32mat2
	static const f32mat2 sup; // limit superior (maximum possible value) of f32mat2
};

template<> struct element_type_information<f32mat3>
{
	typedef f32 value_type; // the value type of f32mat3 ( f32 )
	static constexpr size_t value_count = 9; // the number of values in f32mat3 ( 9 )
	static constexpr const char * value_name = "f32"; // name of the value in f32mat3 ( "f32" ) 
	static constexpr const char * type_name = "f32mat3"; // name of the type ( "f32mat3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32mat3; // the element type index of f32mat3 ( dt_f32mat3 )
	static const f32mat3 zero; // zero value of f32mat3
	static const f32mat3 inf; // limit inferior (minimum possible value) of f32mat3
	static const f32mat3 sup; // limit superior (maximum possible value) of f32mat3
};

template<> struct element_type_information<f32mat4>
{
	typedef f32 value_type; // the value type of f32mat4 ( f32 )
	static constexpr size_t value_count = 16; // the number of values in f32mat4 ( 16 )
	static constexpr const char * value_name = "f32"; // name of the value in f32mat4 ( "f32" ) 
	static constexpr const char * type_name = "f32mat4"; // name of the type ( "f32mat4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32mat4; // the element type index of f32mat4 ( dt_f32mat4 )
	static const f32mat4 zero; // zero value of f32mat4
	static const f32mat4 inf; // limit inferior (minimum possible value) of f32mat4
	static const f32mat4 sup; // limit superior (maximum possible value) of f32mat4
};

template<> struct element_type_information<f64mat2>
{
	typedef f64 value_type; // the value type of f64mat2 ( f64 )
	static constexpr size_t value_count = 4; // the number of values in f64mat2 ( 4 )
	static constexpr const char * value_name = "f64"; // name of the value in f64mat2 ( "f64" ) 
	static constexpr const char * type_name = "f64mat2"; // name of the type ( "f64mat2" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64mat2; // the element type index of f64mat2 ( dt_f64mat2 )
	static const f64mat2 zero; // zero value of f64mat2
	static const f64mat2 inf; // limit inferior (minimum possible value) of f64mat2
	static const f64mat2 sup; // limit superior (maximum possible value) of f64mat2
};

template<> struct element_type_information<f64mat3>
{
	typedef f64 value_type; // the value type of f64mat3 ( f64 )
	static constexpr size_t value_count = 9; // the number of values in f64mat3 ( 9 )
	static constexpr const char * value_name = "f64"; // name of the value in f64mat3 ( "f64" ) 
	static constexpr const char * type_name = "f64mat3"; // name of the type ( "f64mat3" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64mat3; // the element type index of f64mat3 ( dt_f64mat3 )
	static const f64mat3 zero; // zero value of f64mat3
	static const f64mat3 inf; // limit inferior (minimum possible value) of f64mat3
	static const f64mat3 sup; // limit superior (maximum possible value) of f64mat3
};

template<> struct element_type_information<f64mat4>
{
	typedef f64 value_type; // the value type of f64mat4 ( f64 )
	static constexpr size_t value_count = 16; // the number of values in f64mat4 ( 16 )
	static constexpr const char * value_name = "f64"; // name of the value in f64mat4 ( "f64" ) 
	static constexpr const char * type_name = "f64mat4"; // name of the type ( "f64mat4" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64mat4; // the element type index of f64mat4 ( dt_f64mat4 )
	static const f64mat4 zero; // zero value of f64mat4
	static const f64mat4 inf; // limit inferior (minimum possible value) of f64mat4
	static const f64mat4 sup; // limit superior (maximum possible value) of f64mat4
};

template<> struct element_type_information<f32quat>
{
	typedef f32 value_type; // the value type of f32quat ( f32 )
	static constexpr size_t value_count = 4; // the number of values in f32quat ( 4 )
	static constexpr const char * value_name = "f32"; // name of the value in f32quat ( "f32" ) 
	static constexpr const char * type_name = "f32quat"; // name of the type ( "f32quat" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f32quat; // the element type index of f32quat ( dt_f32quat )
	static const f32quat zero; // zero value of f32quat
	static const f32quat inf; // limit inferior (minimum possible value) of f32quat
	static const f32quat sup; // limit superior (maximum possible value) of f32quat
};

template<> struct element_type_information<f64quat>
{
	typedef f64 value_type; // the value type of f64quat ( f64 )
	static constexpr size_t value_count = 4; // the number of values in f64quat ( 4 )
	static constexpr const char * value_name = "f64"; // name of the value in f64quat ( "f64" ) 
	static constexpr const char * type_name = "f64quat"; // name of the type ( "f64quat" ) 
	static constexpr element_type_index type_index = element_type_index::dt_f64quat; // the element type index of f64quat ( dt_f64quat )
	static const f64quat zero; // zero value of f64quat
	static const f64quat inf; // limit inferior (minimum possible value) of f64quat
	static const f64quat sup; // limit superior (maximum possible value) of f64quat
};

template<> struct element_type_information<uuid>
{
	typedef uuid value_type; // the value type of uuid ( uuid )
	static constexpr size_t value_count = 1; // the number of values in uuid ( 1 )
	static constexpr const char * value_name = "uuid"; // name of the value in uuid ( "uuid" ) 
	static constexpr const char * type_name = "uuid"; // name of the type ( "uuid" ) 
	static constexpr element_type_index type_index = element_type_index::dt_uuid; // the element type index of uuid ( dt_uuid )
	static const uuid zero; // zero value of uuid
	static const uuid inf; // limit inferior (minimum possible value) of uuid
	static const uuid sup; // limit superior (maximum possible value) of uuid
};

template<> struct element_type_information<item_ref>
{
	typedef item_ref value_type; // the value type of item_ref ( item_ref )
	static constexpr size_t value_count = 1; // the number of values in item_ref ( 1 )
	static constexpr const char * value_name = "item_ref"; // name of the value in item_ref ( "item_ref" ) 
	static constexpr const char * type_name = "item_ref"; // name of the type ( "item_ref" ) 
	static constexpr element_type_index type_index = element_type_index::dt_item_ref; // the element type index of item_ref ( dt_item_ref )
	static const item_ref zero; // zero value of item_ref
	static const item_ref inf; // limit inferior (minimum possible value) of item_ref
	static const item_ref sup; // limit superior (maximum possible value) of item_ref
};

template<> struct element_type_information<hash>
{
	typedef hash value_type; // the value type of hash ( hash )
	static constexpr size_t value_count = 1; // the number of values in hash ( 1 )
	static constexpr const char * value_name = "hash"; // name of the value in hash ( "hash" ) 
	static constexpr const char * type_name = "hash"; // name of the type ( "hash" ) 
	static constexpr element_type_index type_index = element_type_index::dt_hash; // the element type index of hash ( dt_hash )
	static const hash zero; // zero value of hash
	static const hash inf; // limit inferior (minimum possible value) of hash
	static const hash sup; // limit superior (maximum possible value) of hash
};

template<> struct element_type_information<entity_ref>
{
	typedef entity_ref value_type; // the value type of entity_ref ( entity_ref )
	static constexpr size_t value_count = 1; // the number of values in entity_ref ( 1 )
	static constexpr const char * value_name = "entity_ref"; // name of the value in entity_ref ( "entity_ref" ) 
	static constexpr const char * type_name = "entity_ref"; // name of the type ( "entity_ref" ) 
	static constexpr element_type_index type_index = element_type_index::dt_entity_ref; // the element type index of entity_ref ( dt_entity_ref )
	static const entity_ref zero; // zero value of entity_ref
	static const entity_ref inf; // limit inferior (minimum possible value) of entity_ref
	static const entity_ref sup; // limit superior (maximum possible value) of entity_ref
};

template<> struct element_type_information<string>
{
	typedef string value_type; // the value type of string ( string )
	static constexpr size_t value_count = 1; // the number of values in string ( 1 )
	static constexpr const char * value_name = "string"; // name of the value in string ( "string" ) 
	static constexpr const char * type_name = "string"; // name of the type ( "string" ) 
	static constexpr element_type_index type_index = element_type_index::dt_string; // the element type index of string ( dt_string )
	static const string zero; // zero value of string
	static const string inf; // limit inferior (minimum possible value) of string
};

}
// namespace pds
#ifdef PDS_IMPLEMENTATION
#include "element_types.inl"
#endif//PDS_IMPLEMENTATION

#endif//__PDS__ELEMENT_TYPES_H__
