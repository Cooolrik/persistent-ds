# pds - Persistent data structure framework, Copyright (c) 2022 Ulrik Lindahl
# Licensed under the MIT license https://github.com/Cooolrik/pds/blob/main/LICENSE

import os
from ctlepy.file_checker import line_define
from ctlepy.file_checker import check_file_lines
from ctlepy.file_checker import fix_file
import pathlib
from pathlib import Path

# Set to True to fix files, False to only check and report errors
# Note that this will not fix all errors, and the files will still need to be checked manually
fix_fails = False

autogen_warning = "WARNING! DO NOT EDIT THIS FILE! This file is generated."
name = "pds - Persistent data structure framework"
copyright_regex = r"Copyright \(c\) \d{4} Ulrik Lindahl" 
copyright_ex = "Copyright (c) 2022 Ulrik Lindahl"

# Function to check both license and #ifdef in files
def check_file(file_path: Path) -> bool:
	print(f"Checking file: {file_path}")

	# the comment string depends on the file type
	comment = "# " if file_path.suffix == ".py" else "// "

	# check if the file is autogenerated
	defs = [
		line_define(1, comment + autogen_warning),
		line_define(2, ""),
	]
	next_row = 3

	# if autogen, continue. if not, restart at row 1
	autogen = len(check_file_lines(file_path, defs)) == 0
	if not autogen:
		next_row = 1
		defs = []

	# add license check to the list of definitions
	defs = [
		line_define(next_row + 0, comment + name + ", " + copyright_regex, comment + name + ", " + copyright_ex),
		line_define(next_row + 1, comment + name + ", " + copyright_regex, comment + name + ", " + copyright_ex),
	]
	next_row += 2

	# for header files, we need to check for #pragma once and #ifndef include guards
	if file_path.suffix == ".h":
		
		# header files, check for #pragma once and #ifndef include guards
		file_title = file_path.stem.upper().replace("-", "_").replace(" ", "_")
		extension = file_path.suffix[1:].upper()  # Remove the leading dot and convert to uppercase
		file_def = f"__PDS__{file_title}_{extension}__"		

		defs.extend( [
			line_define(next_row + 0,"#pragma once"),
			line_define(next_row + 1,f"#ifndef {file_def}"),
			line_define(next_row + 2,f"#define {file_def}"),
			line_define(-1,f"#endif//{file_def}"),
		] )
		next_row += 3

	# check the file for the defined lines
	if len(check_file_lines(file_path, defs)) > 0:
		if not autogen or not fix_fails:
			return False
		else:
			print(f"Fixing file: {file_path}")
			return fix_file(file_path, defs)

	# file passes all checks, return True
	return True

# Function to traverse directories and check files
def check_files_in_directory(repo_root:pathlib.Path, subdir:str) -> list:
	directory = repo_root / subdir
	file_types = (".cpp", ".h", ".inl", ".py")
	invalid_headers = set()

	# check all files in directory
	files = [file for file in os.listdir(directory) if file.endswith(file_types)]
	for file in files:
		file_path = repo_root / subdir / file
		if not check_file(file_path):
			invalid_headers.add(f"File: {file_path} fails header check")

	return invalid_headers

if __name__ == "__main__":
	pds_root = pathlib.Path(__file__).parent.parent.resolve()

	errors = []
	source_directories = ["include/pds"]
	for subdir in source_directories:
		errors.extend(check_files_in_directory(pds_root,subdir))

	if len(errors) > 0:
		print(f"\033[31mFound {len(errors)} Errors:")
		for f in errors:
			print(f)
		print("\033[0m")
		exit(-1)
	else:
		print("All files checks out ok")
		exit(0)
