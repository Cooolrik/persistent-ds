// WARNING! DO NOT EDIT THIS FILE! This file is generated.

// pds - Persistent data structure framework, Copyright (c) 2022 Ulrik Lindahl
// Licensed under the MIT license https://github.com/Cooolrik/pds/blob/main/LICENSE
#include "Tests.h"
#include <pds/mf/Varying_MF.h>
#include <pds/EntityWriter.h>
#include <pds/EntityReader.h>
#include <pds/WriteStream.h>
#include <pds/ReadStream.h>

using pds::Varying;

template<class _Ty> void VaryingValueTester()
    {
    constexpr pds::element_type_index element_index = pds::element_type_information<_Ty>::type_index;

    // test container type: none 
    {
        constexpr pds::container_type_index container_index = container_type_index::ct_none;

        // create objects of the type, one dynamically typed in the heap and one statically typed on the stack
        Varying value;
        EXPECT_FALSE( value.IsInitialized() );
        status result = value.Initialize( element_index, container_index );
        EXPECT_TRUE( result );
        EXPECT_TRUE( value.IsInitialized() );
        EXPECT_TRUE( value.IsA<_Ty>() );
        _Ty &dataA = value.Data<_Ty>();
        random_nonzero_value<_Ty>( dataA );
        Varying value2;
        EXPECT_FALSE( value2.IsInitialized() );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::DeepCopy( value2, &value );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value2 );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
    }

    // test container type: optional_value 
    {
        constexpr pds::container_type_index container_index = container_type_index::ct_optional_value;

        // create objects of the type, one dynamically typed in the heap and one statically typed on the stack
        Varying value;
        EXPECT_FALSE( value.IsInitialized() );
        status result = value.Initialize( element_index, container_index );
        EXPECT_TRUE( result );
        EXPECT_TRUE( value.IsInitialized() );
        EXPECT_TRUE( value.IsA<pds::optional_value<_Ty>>() );
        pds::optional_value<_Ty> &dataA = value.Data<pds::optional_value<_Ty>>();
        random_nonzero_optional_value<_Ty>( dataA );
        Varying value2;
        EXPECT_FALSE( value2.IsInitialized() );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::DeepCopy( value2, &value );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value2 );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
    }

    // test container type: vector 
    {
        constexpr pds::container_type_index container_index = container_type_index::ct_vector;

        // create objects of the type, one dynamically typed in the heap and one statically typed on the stack
        Varying value;
        EXPECT_FALSE( value.IsInitialized() );
        status result = value.Initialize( element_index, container_index );
        EXPECT_TRUE( result );
        EXPECT_TRUE( value.IsInitialized() );
        EXPECT_TRUE( value.IsA<pds::vector<_Ty>>() );
        pds::vector<_Ty> &dataA = value.Data<pds::vector<_Ty>>();
        random_nonzero_vector<_Ty>( dataA );
        Varying value2;
        EXPECT_FALSE( value2.IsInitialized() );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::DeepCopy( value2, &value );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value2 );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
    }

    // test container type: optional_vector 
    {
        constexpr pds::container_type_index container_index = container_type_index::ct_optional_vector;

        // create objects of the type, one dynamically typed in the heap and one statically typed on the stack
        Varying value;
        EXPECT_FALSE( value.IsInitialized() );
        status result = value.Initialize( element_index, container_index );
        EXPECT_TRUE( result );
        EXPECT_TRUE( value.IsInitialized() );
        EXPECT_TRUE( value.IsA<pds::optional_vector<_Ty>>() );
        pds::optional_vector<_Ty> &dataA = value.Data<pds::optional_vector<_Ty>>();
        random_nonzero_optional_vector<_Ty>( dataA );
        Varying value2;
        EXPECT_FALSE( value2.IsInitialized() );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::DeepCopy( value2, &value );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value2 );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
    }

    // test container type: idx_vector 
    {
        constexpr pds::container_type_index container_index = container_type_index::ct_idx_vector;

        // create objects of the type, one dynamically typed in the heap and one statically typed on the stack
        Varying value;
        EXPECT_FALSE( value.IsInitialized() );
        status result = value.Initialize( element_index, container_index );
        EXPECT_TRUE( result );
        EXPECT_TRUE( value.IsInitialized() );
        EXPECT_TRUE( value.IsA<pds::idx_vector<_Ty>>() );
        pds::idx_vector<_Ty> &dataA = value.Data<pds::idx_vector<_Ty>>();
        random_nonzero_idx_vector<_Ty>( dataA );
        Varying value2;
        EXPECT_FALSE( value2.IsInitialized() );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::DeepCopy( value2, &value );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value2 );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
    }

    // test container type: optional_idx_vector 
    {
        constexpr pds::container_type_index container_index = container_type_index::ct_optional_idx_vector;

        // create objects of the type, one dynamically typed in the heap and one statically typed on the stack
        Varying value;
        EXPECT_FALSE( value.IsInitialized() );
        status result = value.Initialize( element_index, container_index );
        EXPECT_TRUE( result );
        EXPECT_TRUE( value.IsInitialized() );
        EXPECT_TRUE( value.IsA<pds::optional_idx_vector<_Ty>>() );
        pds::optional_idx_vector<_Ty> &dataA = value.Data<pds::optional_idx_vector<_Ty>>();
        random_nonzero_optional_idx_vector<_Ty>( dataA );
        Varying value2;
        EXPECT_FALSE( value2.IsInitialized() );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::DeepCopy( value2, &value );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value );
        EXPECT_FALSE( Varying::MF::Equals( &value, &value2) );
        Varying::MF::Clear( value2 );
        EXPECT_TRUE( Varying::MF::Equals( &value, &value2) );
    }

    }

TEST( VaryingTests , VaryingValues )
    {
    setup_random_seed();
    for( uint pass_index=0; pass_index<global_number_of_passes; ++pass_index )
        {
        VaryingValueTester<bool>();
        VaryingValueTester<i8>();
        VaryingValueTester<i16>();
        VaryingValueTester<i32>();
        VaryingValueTester<i64>();
        VaryingValueTester<u8>();
        VaryingValueTester<u16>();
        VaryingValueTester<u32>();
        VaryingValueTester<u64>();
        VaryingValueTester<f32>();
        VaryingValueTester<f64>();
        VaryingValueTester<f32vec2>();
        VaryingValueTester<f64vec2>();
        VaryingValueTester<f32vec3>();
        VaryingValueTester<f64vec3>();
        VaryingValueTester<f32vec4>();
        VaryingValueTester<f64vec4>();
        VaryingValueTester<i8vec2>();
        VaryingValueTester<i16vec2>();
        VaryingValueTester<i32vec2>();
        VaryingValueTester<i64vec2>();
        VaryingValueTester<i8vec3>();
        VaryingValueTester<i16vec3>();
        VaryingValueTester<i32vec3>();
        VaryingValueTester<i64vec3>();
        VaryingValueTester<i8vec4>();
        VaryingValueTester<i16vec4>();
        VaryingValueTester<i32vec4>();
        VaryingValueTester<i64vec4>();
        VaryingValueTester<u8vec2>();
        VaryingValueTester<u16vec2>();
        VaryingValueTester<u32vec2>();
        VaryingValueTester<u64vec2>();
        VaryingValueTester<u8vec3>();
        VaryingValueTester<u16vec3>();
        VaryingValueTester<u32vec3>();
        VaryingValueTester<u64vec3>();
        VaryingValueTester<u8vec4>();
        VaryingValueTester<u16vec4>();
        VaryingValueTester<u32vec4>();
        VaryingValueTester<u64vec4>();
        VaryingValueTester<f32mat2>();
        VaryingValueTester<f64mat2>();
        VaryingValueTester<f32mat3>();
        VaryingValueTester<f64mat3>();
        VaryingValueTester<f32mat4>();
        VaryingValueTester<f64mat4>();
        VaryingValueTester<f32quat>();
        VaryingValueTester<f64quat>();
        VaryingValueTester<uuid>();
        VaryingValueTester<item_ref>();
        VaryingValueTester<hash>();
        VaryingValueTester<entity_ref>();
        VaryingValueTester<string>();
        }
    }
